-- this is an example of an early media application, that
-- has to do some possibly blocking operation on start of processing,
-- so session processing is delayed (here with timer 1)
-- later 183 is sent, and after playing a message, 200 OK is sent, 
-- and 10 seconds are recorded to a file.

import(mod_dlg);

initial state START ;
transition "on invite" START - invite -> runinvite;

state runinvite 
      enter { 
       log(2, run invite!); 
       dlg.reply(100, trying...);
       -- we don't want to have the default 200 OK reply
       set(connect_session=0);
       setTimer(1, 2);
};

transition "go early" runinvite - timerTest(#id==1) / {
        dlg.acceptInvite(183, progress);
} -> replied_183;

state replied_183;

transition "on sess start" runinvite - earlySession -> play_early_msg;
state play_early_msg
      enter {
       log(2, run start!);
       connectMedia();
       playFile(wav/default_en.wav);
};

transition "play file failed" runinvite - exception; test(#type==file) / {
        log(1, Error playing file!); 
        dlg.reply(500, server error); 
        stop 
} -> FIN;

transition "early message ended" replied_183 - noAudioTest / {
        dlg.acceptInvite(200, ok);
        recordFile(/tmp/test.wav);
        setTimer(3,10);
} -> recording;

state recording;

transition "recording failed" replied_183 - exception; / 
   log(1, Error recording!); stop(true) -> FIN;

transition "bye in early" (replied_183, play_early_msg, runinvite) - hangup / {
	log(2, hangup event received);
        stop(false)
} -> FIN;

transition "recording timer" recording - timerTest(#id==3) / stop -> FIN;

transition "bye in recording" recording - hangup / stop -> FIN;

state FIN;
